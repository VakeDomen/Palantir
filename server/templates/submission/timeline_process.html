<div id="procChartWrap-{{ id }}" style="height:300px">
  <canvas id="procChart-{{ id }}"></canvas>
</div>

<script>
(function () {
  const cid = "procChart-{{ id }}";
  const wrapId = "procChartWrap-{{ id }}";
  const key = "__chartInst_" + cid;

  if (window[key]) { try { window[key].destroy(); } catch (_) {} window[key] = null; }

  const wrapEl = document.getElementById(wrapId);
  const canvas = document.getElementById(cid);
  if (!wrapEl || !canvas) return;

  // Pulled from Rust consts via Tera context
  const CHEAT_HIGHLIGHT = {{ CHEAT_HIGHLIGHT_JSON | safe }};
  const SYSTEM_HIDE     = {{ SYSTEM_HIDE_JSON | safe }};

  fetch("/admin/submissions/{{ id }}/proc_timeline.json")
    .then(r => r.json())
    .then(data => {
      const prioSet = new Set(CHEAT_HIGHLIGHT.map(s => s.toLowerCase()));
      const hideSet = new Set(SYSTEM_HIDE.map(s => s.toLowerCase()));

      function matchesSet(label, set) {
        const l = String(label).toLowerCase();
        if (set.has(l)) return true;
        for (const key of set) {
          if (key.startsWith(l)) return true;
        }
        return false;
      }

      console.log(data.rows.map(e => e.label).join(", "));

      let rows = data.rows.filter(r => !matchesSet(r.label, hideSet));

      // priority first
      rows.sort((a, b) => {
        const pa = matchesSet(a.label, prioSet) ? 0 : 1;
        const pb = matchesSet(b.label, prioSet) ? 0 : 1;
        return pa - pb;
      });

      // dynamic height
      const count = rows.length;
      wrapEl.style.height = Math.max(220, 30 * count + 40) + "px";

      const yLabels = rows.map(r => r.label);
      const yTickColor = (ctx) => matchesSet(ctx.tick.label, prioSet) ? "red" : "gray";

      const ctx = canvas.getContext("2d");
      window[key] = new Chart(ctx, {
        type: "bar",
        data: {
          datasets: rows.map(row => ({
            label: row.label,
            data: row.segments.map(seg => ({ y: row.label, x: [seg.start, seg.end] }))
          }))
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: "y",
          scales: {
            x: {
              type: "time",
              time: { unit: "minute" },
              min: data.tmin,
              max: data.tmax
            },
            y: {
              type: "category",
              labels: yLabels,
              ticks: { autoSkip: false, color: yTickColor },
              offset: true
            }
          },
          barPercentage: 5.4,
          plugins: { legend: { display: false } },
          elements: { bar: { borderSkipped: false, barThickness: "3px" } }
        }
      });
    })
    .catch(err => console.error("proc timeline fetch error", err));
})();
</script>
